"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortalSDK = void 0;
const ws_1 = __importDefault(require("ws"));
/**
 * Portal client for interacting with the Portal server
 */
class PortalSDK {
    /**
     * Create a new Portal client
     */
    constructor(config) {
        this.socket = null;
        this.connected = false;
        this.commandCallbacks = new Map();
        this.eventListeners = new Map();
        this.isAuthenticated = false;
        this.reconnectAttempts = 0;
        this.eventCallbacks = {};
        this.activeStreams = new Map();
        this.config = {
            connectTimeout: 10000,
            ...config
        };
    }
    /**
     * Connect to the Portal server
     */
    async connect() {
        if (this.connected) {
            return;
        }
        return new Promise((resolve, reject) => {
            try {
                this.socket = new ws_1.default(this.config.serverUrl);
                const timeout = setTimeout(() => {
                    if (this.socket && this.socket.readyState !== ws_1.default.OPEN) {
                        this.socket.close();
                        reject(new Error('Connection timeout'));
                    }
                }, this.config.connectTimeout);
                this.socket.onopen = () => {
                    this.connected = true;
                    clearTimeout(timeout);
                    resolve();
                };
                this.socket.onclose = () => {
                    this.connected = false;
                    this.socket = null;
                };
                this.socket.onerror = (error) => {
                    if (!this.connected) {
                        clearTimeout(timeout);
                        reject(error);
                    }
                };
                this.socket.onmessage = (event) => this.handleMessage(event);
            }
            catch (error) {
                reject(error);
            }
        });
    }
    /**
     * Disconnect from the Portal server
     */
    disconnect() {
        if (this.socket) {
            this.socket.close();
            this.socket = null;
            this.connected = false;
            this.isAuthenticated = false;
            // Clear all active streams and callbacks
            this.activeStreams.clear();
            this.commandCallbacks.clear();
            this.eventListeners.clear();
        }
    }
    /**
     * Send a command to the server and wait for the response
     */
    async sendCommand(cmd, params = {}) {
        if (!this.connected || !this.socket) {
            throw new Error('Not connected to server');
        }
        const id = this.generateId();
        // Format command to match server's expected format
        const command = {
            id,
            cmd,
            ...(Object.keys(params).length > 0 ? { params } : {})
        };
        console.log('Sending command:', JSON.stringify(command, null, 2));
        console.log('Registered callback for id:', id);
        return new Promise((resolve, reject) => {
            this.commandCallbacks.set(id, { resolve, reject });
            this.socket.send(JSON.stringify(command));
        });
    }
    /**
     * Register an event listener or event callbacks
     */
    on(eventType, callback) {
        // Handle object form (EventCallbacks)
        if (typeof eventType === 'object') {
            this.eventCallbacks = { ...this.eventCallbacks, ...eventType };
            return;
        }
        // Handle string form with callback
        if (typeof eventType === 'string' && callback) {
            if (!this.eventListeners.has(eventType)) {
                this.eventListeners.set(eventType, []);
            }
            this.eventListeners.get(eventType).push(callback);
        }
    }
    /**
     * Remove an event listener
     */
    off(eventType, callback) {
        if (!this.eventListeners.has(eventType)) {
            return;
        }
        const listeners = this.eventListeners.get(eventType);
        const index = listeners.indexOf(callback);
        if (index !== -1) {
            listeners.splice(index, 1);
        }
    }
    /**
     * Handle messages from the server
     */
    handleMessage(event) {
        try {
            const data = JSON.parse(event.data.toString());
            console.log('Received message:', JSON.stringify(data, null, 2));
            // Handle command responses
            if ('id' in data) {
                const response = data;
                console.log('Looking for callback with id:', response.id);
                const callback = this.commandCallbacks.get(response.id);
                this.commandCallbacks.delete(response.id);
                if (callback) {
                    console.log('Found callback for id:', response.id);
                    if (response.type === 'error') {
                        callback.reject(new Error(response.message));
                    }
                    else if (response.type === 'success') {
                        callback.resolve(response.data);
                    }
                }
                else if (response.type === 'notification') {
                    const streamId = response.id;
                    const handler = this.activeStreams.get(streamId);
                    if (handler) {
                        handler(response.data);
                    }
                    else {
                        console.log('No handler found for stream id:', streamId);
                    }
                }
                else {
                    console.log('No callback found for id:', response.id);
                }
                return;
            }
            // Handle events
            if ('type' in data) {
                const eventData = data;
                const listeners = this.eventListeners.get(eventData.type);
                if (listeners) {
                    listeners.forEach(listener => listener(eventData.data));
                }
                // Also trigger 'all' event listeners
                const allListeners = this.eventListeners.get('all');
                if (allListeners) {
                    allListeners.forEach(listener => listener(eventData));
                }
            }
        }
        catch (error) {
            console.error('Error handling message:', error);
        }
    }
    /**
     * Generate a unique ID for commands
     */
    generateId() {
        return Math.random().toString(36).substring(2, 15) +
            Math.random().toString(36).substring(2, 15);
    }
    /**
     * Authenticate with the server using a token
     */
    async authenticate(token) {
        const response = await this.sendCommand('Auth', { token });
        if (response.type === 'error') {
            throw new Error(`Authentication failed: ${response.message}`);
        }
        this.isAuthenticated = true;
        this.reconnectAttempts = 0; // Reset reconnect attempts on successful auth
    }
    /**
     * Generate a new key handshake URL
     */
    async newKeyHandshakeUrl(onKeyHandshake, staticToken = null, noRequest = false) {
        const _self = this;
        let streamId = '';
        const handler = (data) => {
            if (data.type === 'key_handshake') {
                onKeyHandshake(data.main_key, data.preferred_relays);
                _self.activeStreams.delete(streamId);
            }
        };
        const response = await this.sendCommand('NewKeyHandshakeUrl', { static_token: staticToken, no_request: noRequest });
        if (response.type === 'key_handshake_url') {
            const { url, stream_id } = response;
            streamId = stream_id;
            this.activeStreams.set(stream_id, handler);
            return url;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Authenticate a key with the server
     */
    async authenticateKey(mainKey, subkeys = []) {
        const response = await this.sendCommand('AuthenticateKey', { main_key: mainKey, subkeys });
        if (response.type === 'auth_response') {
            return response.event;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Request a recurring payment
     */
    async requestRecurringPayment(mainKey, subkeys = [], paymentRequest) {
        const response = await this.sendCommand('RequestRecurringPayment', { main_key: mainKey, subkeys, payment_request: paymentRequest });
        if (response.type === 'recurring_payment') {
            return response.status;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Request a single payment
     * @param mainKey The main key to use for authentication
     * @param subkeys Optional subkeys for authentication
     * @param paymentRequest The payment request details
     * @param onStatusChange Callback function to handle payment status updates
     * @returns The initial payment status
     */
    async requestSinglePayment(mainKey, subkeys = [], paymentRequest, onStatusChange) {
        const _self = this;
        let streamId;
        const handler = (data) => {
            if (data.type === 'payment_status_update') {
                onStatusChange(data.status);
                if (data.status.status === 'user_failed' || data.status.status === 'user_rejected') {
                    console.log('Deleting stream id:', streamId);
                    _self.activeStreams.delete(streamId);
                }
            }
        };
        const response = await this.sendCommand('RequestSinglePayment', { main_key: mainKey, subkeys, payment_request: paymentRequest });
        if (response.type === 'single_payment') {
            streamId = response.stream_id;
            this.activeStreams.set(streamId, handler);
            return;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Request the user to pay an invoice
     * @param mainKey The main key to use for authentication
     * @param subkeys Optional subkeys for authentication
     * @param paymentRequest The payment request details
     * @returns The initial payment status
     */
    async requestInvoicePayment(mainKey, subkeys = [], paymentRequest, onStatusChange) {
        const _self = this;
        let streamId;
        const handler = (data) => {
            if (data.type === 'payment_status_update') {
                onStatusChange(data.status);
                if (data.status.status === 'user_failed' || data.status.status === 'user_rejected') {
                    console.log('Deleting stream id:', streamId);
                    _self.activeStreams.delete(streamId);
                }
            }
        };
        const response = await this.sendCommand('RequestPaymentRaw', { main_key: mainKey, subkeys, payment_request: paymentRequest });
        if (response.type === 'single_payment') {
            streamId = response.stream_id;
            this.activeStreams.set(streamId, handler);
            return;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Fetch a user profile
     */
    async fetchProfile(mainKey) {
        const response = await this.sendCommand('FetchProfile', { main_key: mainKey });
        if (response.type === 'profile') {
            return response.profile;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Set a user profile
     */
    async setProfile(profile) {
        await this.sendCommand('SetProfile', { profile });
    }
    /**
     * Close a recurring payment
     */
    async closeRecurringPayment(mainKey, subkeys, subscriptionId) {
        const response = await this.sendCommand('CloseRecurringPayment', { main_key: mainKey, subkeys, subscription_id: subscriptionId });
        if (response.type === 'close_recurring_payment_success') {
            return response.message;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Listen for closed recurring payments
     */
    async listenClosedRecurringPayment(onClosed) {
        const handler = (data) => {
            if (data.type === 'closed_recurring_payment') {
                onClosed({
                    reason: data.reason,
                    subscription_id: data.subscription_id,
                    main_key: data.main_key,
                    recipient: data.recipient
                });
                // _self.activeStreams.delete(streamId);
            }
        };
        const response = await this.sendCommand('ListenClosedRecurringPayment');
        if (response.type === 'listen_closed_recurring_payment') {
            this.activeStreams.set(response.stream_id, handler);
            return;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Request an invoice
     */
    async requestInvoice(recipientKey, content) {
        return this.sendCommand('RequestInvoice', {
            recipient_key: recipientKey,
            content
        });
    }
    /**
     * Issue a JWT token for a given target key
     */
    async issueJwt(target_key, duration_hours) {
        return this.sendCommand('IssueJwt', {
            target_key,
            duration_hours
        }).then(response => response.token);
    }
    /**
     * Verify a JWT token and return the claims
     */
    async verifyJwt(public_key, token) {
        return this.sendCommand('VerifyJwt', {
            pubkey: public_key,
            token
        }).then(response => ({
            target_key: response.target_key,
        }));
    }
    /**
     * Request a Cashu token from a recipient
     */
    async requestCashu(recipientKey, subkeys, mint_url, unit, amount) {
        const response = await this.sendCommand('RequestCashu', { recipient_key: recipientKey, subkeys, mint_url, unit, amount });
        if (response.type === 'cashu_response') {
            return response.status;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Send a Cashu token directly to a recipient
     */
    async sendCashuDirect(mainKey, subkeys, token) {
        const response = await this.sendCommand('SendCashuDirect', { main_key: mainKey, subkeys, token });
        if (response.type === 'send_cashu_direct_success') {
            return response.message;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Mint a Cashu token from a mint and return it
     */
    async mintCashu(mint_url, static_auth_token, unit, amount, description) {
        const response = await this.sendCommand('MintCashu', { mint_url, static_auth_token, unit, amount, description });
        if (response.type === 'cashu_mint') {
            return response.token;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Burn a Cashu token at a mint
     */
    async burnCashu(mint_url, unit, token, static_auth_token) {
        const response = await this.sendCommand('BurnCashu', { mint_url, unit, token, static_auth_token });
        if (response.type === 'cashu_burn') {
            return response.amount;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Add a relay to the relay pool
     */
    async addRelay(relay) {
        const response = await this.sendCommand('AddRelay', { relay });
        if (response.type === 'add_relay') {
            return response.relay;
        }
        throw new Error('Unexpected response type');
    }
    /**
     * Remove a relay from the relay pool
     */
    async removeRelay(relay) {
        const response = await this.sendCommand('RemoveRelay', { relay });
        if (response.type === 'remove_relay') {
            return response.relay;
        }
        throw new Error('Unexpected response type');
    }
}
exports.PortalSDK = PortalSDK;
