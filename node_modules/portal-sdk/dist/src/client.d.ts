import { ClientConfig, EventCallbacks, RecurringPaymentRequestContent, SinglePaymentRequestContent, Profile, AuthResponseData, InvoicePaymentRequestContent, RecurringPaymentResponseContent, CloseRecurringPaymentNotification, InvoiceStatus, InvoiceResponseContent, CashuResponseStatus } from './types';
/**
 * Portal client for interacting with the Portal server
 */
export declare class PortalSDK {
    private config;
    private socket;
    private connected;
    private commandCallbacks;
    private eventListeners;
    private isAuthenticated;
    private reconnectAttempts;
    private eventCallbacks;
    private activeStreams;
    /**
     * Create a new Portal client
     */
    constructor(config: ClientConfig);
    /**
     * Connect to the Portal server
     */
    connect(): Promise<void>;
    /**
     * Disconnect from the Portal server
     */
    disconnect(): void;
    /**
     * Send a command to the server and wait for the response
     */
    sendCommand<T = any>(cmd: string, params?: Record<string, any>): Promise<T>;
    /**
     * Register an event listener or event callbacks
     */
    on(eventType: string | EventCallbacks, callback?: (data: any) => void): void;
    /**
     * Remove an event listener
     */
    off(eventType: string, callback: (data: any) => void): void;
    /**
     * Handle messages from the server
     */
    private handleMessage;
    /**
     * Generate a unique ID for commands
     */
    private generateId;
    /**
     * Authenticate with the server using a token
     */
    authenticate(token: string): Promise<void>;
    /**
     * Generate a new key handshake URL
     */
    newKeyHandshakeUrl(onKeyHandshake: (mainKey: string, preferredRelays: string[]) => void, staticToken?: string | null, noRequest?: boolean | null): Promise<string>;
    /**
     * Authenticate a key with the server
     */
    authenticateKey(mainKey: string, subkeys?: string[]): Promise<AuthResponseData>;
    /**
     * Request a recurring payment
     */
    requestRecurringPayment(mainKey: string, subkeys: string[] | undefined, paymentRequest: RecurringPaymentRequestContent): Promise<RecurringPaymentResponseContent>;
    /**
     * Request a single payment
     * @param mainKey The main key to use for authentication
     * @param subkeys Optional subkeys for authentication
     * @param paymentRequest The payment request details
     * @param onStatusChange Callback function to handle payment status updates
     * @returns The initial payment status
     */
    requestSinglePayment(mainKey: string, subkeys: string[] | undefined, paymentRequest: SinglePaymentRequestContent, onStatusChange: (status: InvoiceStatus) => void): Promise<void>;
    /**
     * Request the user to pay an invoice
     * @param mainKey The main key to use for authentication
     * @param subkeys Optional subkeys for authentication
     * @param paymentRequest The payment request details
     * @returns The initial payment status
     */
    requestInvoicePayment(mainKey: string, subkeys: string[] | undefined, paymentRequest: InvoicePaymentRequestContent, onStatusChange: (status: InvoiceStatus) => void): Promise<void>;
    /**
     * Fetch a user profile
     */
    fetchProfile(mainKey: string): Promise<Profile | null>;
    /**
     * Set a user profile
     */
    setProfile(profile: Profile): Promise<void>;
    /**
     * Close a recurring payment
     */
    closeRecurringPayment(mainKey: string, subkeys: string[], subscriptionId: string): Promise<string>;
    /**
     * Listen for closed recurring payments
     */
    listenClosedRecurringPayment(onClosed: (data: CloseRecurringPaymentNotification) => void): Promise<void>;
    /**
     * Request an invoice
     */
    requestInvoice(recipientKey: string, content: InvoicePaymentRequestContent): Promise<InvoiceResponseContent>;
    /**
     * Issue a JWT token for a given target key
     */
    issueJwt(target_key: string, duration_hours: number): Promise<string>;
    /**
     * Verify a JWT token and return the claims
     */
    verifyJwt(public_key: string, token: string): Promise<{
        target_key: string;
    }>;
    /**
     * Request a Cashu token from a recipient
     */
    requestCashu(recipientKey: string, subkeys: string[], mint_url: string, unit: string, amount: number): Promise<CashuResponseStatus>;
    /**
     * Send a Cashu token directly to a recipient
     */
    sendCashuDirect(mainKey: string, subkeys: string[], token: string): Promise<string>;
    /**
     * Mint a Cashu token from a mint and return it
     */
    mintCashu(mint_url: string, static_auth_token: string | undefined, unit: string, amount: number, description?: string): Promise<string>;
    /**
     * Burn a Cashu token at a mint
     */
    burnCashu(mint_url: string, unit: string, token: string, static_auth_token?: string): Promise<number>;
    /**
     * Add a relay to the relay pool
     */
    addRelay(relay: string): Promise<string>;
    /**
     * Remove a relay from the relay pool
     */
    removeRelay(relay: string): Promise<string>;
}
